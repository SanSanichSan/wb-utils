#!/bin/bash
#set -e
#set -x

TMPDIR="/dev/shm"
FIT=""
FLAGS=""

[[ $EUID != 0 ]] && die "Need root privileges to install update"

while [[ -n "$1" ]]; do
	case "$1" in
		--*|-*)
			FLAGS+="$1 "
			;;
		*)
			[[ -n "$FIT" ]] && die "Bad arguments"
			FIT=`readlink -f $1`
			;;
	esac
	shift
done

[[ -n "$FIT" ]] || die "FIT $FIT not found"

# Some handy functions, usable in install script
flag_set() {
	grep -- "--$1 " 2>&1 > /dev/null <<< "$FLAGS"
}

rm_fit() {
	flag_set no-remove && return 0
	info "Removing FIT $FIT"
	rm -f "$FIT"
}

flag_set no-mqtt && {
	mqtt_status() { :; }

	mqtt_progress() {
		while read x; do
			echo -en "\rPROGRESS: $x%"
		done
		echo
	}
} || {
	mqtt_status() {
		mosquitto_pub -t /firmware/status -r -m "$*" 2>/dev/null >/dev/null || true
	}

	mqtt_progress() {
		mosquitto_pub -t /firmware/progress -l 2>/dev/null >/dev/null || true
	}
}

to_hex() {
	od -t x1 |
	sed -r 's/^[^ ]+( |$)//; s/ //g; /^$/d' |
	tr -d '\n'
}

led() {
    echo $3 > /sys/class/leds/$1/$2 || true
}

led_process() {
    led green trigger timer
    led green delay_on 500
    led green delay_off 500

    led red trigger mmc0
}

led_success() {
    led green trigger none
    led green brightness 255

    led red trigger none
    led red brightness 0
}

led_failure() {
    led green trigger none
    led green brightness 0

    led red trigger timer
    led red delay_on 500
    led red delay_off 500
}

led_prompt() {
    led green trigger none
    led green brightness 0

    led red trigger timer
    led red delay_on 100
    led red delay_off 100
}

PLATFORM=`cat /proc/cpuinfo | grep Hardware | awk '{print $4}'`

if [[ $PLATFORM == "i.MX6" ]]; then
    button_read() {
        local gpioid=138 # iMX6UL boot button GPIO
        local expected=$1
        [[ -d /sys/class/gpio/gpio$gpioid ]] || echo $gpioid > /sys/class/gpio/export

        local value=`cat /sys/class/gpio/gpio$gpioid/value`
        [[ "x$value" == "x$expected" ]]
    }
else
    button_read() {
        local exp=$1
        local val=`memdump 0x800440c2 1 | busybox hexdump -e '"%x"' | head -c 1 | tr 13 01`
        [[ "x$val" == "x$exp" ]]
    }
fi

_button_wait_r() {
    local invert=$1
    local presstime=$2
    presstime=${presstime:=1}

    while [[ $presstime -gt 0 ]] && [[ $BUTTON_TIMEOUT -gt 0 ]]; do
       sleep 0.2
       BUTTON_TIMEOUT=$((BUTTON_TIMEOUT - 1))
       button_read $invert || presstime=$((presstime - 1))
    done

    [[ $BUTTON_TIMEOUT -gt 0 ]]
}

button_wait() {
    BUTTON_TIMEOUT=$1
    BUTTON_TIMEOUT=$((BUTTON_TIMEOUT * 5))  # to be in sync with sleep 0.2

    local presstime=$2
    if [[ "x$presstime" == "x" ]]; then
        presstime=1
    else
        presstime=$((presstime * 5))
    fi

    _button_wait_r 1 # wait for button to be released
    _button_wait_r 0 $presstime
}

user_button_confirm() {
    local message=$1
    local timeout=$2
    local presstime=$3

    [[ "x$presstime" != "x" ]] && local infotime="for more than $presstime seconds "

    info "Press the button ${infotime}${message}"
    led_prompt
    button_wait $timeout $presstime
    local ret=$?
    led_process

    return $ret
}

die() {
	local ret=$?
	local msg=${*:-"Failed"}
	>&2 echo "!!! $msg"
	mqtt_status "ERROR $msg"
	mqtt_status "IDLE"
	rm_fit
	[[ $? == 0 ]] && exit 1 || exit $?
}

info() {
	>&2 echo ">>> $*"
	mqtt_status "INFO $*"
}

fit_prop() {
	local node=$1
	local prop=$2

	local tmp=`fit_info -f $FIT -n $node -p $prop`
	local len=`sed -rn 's#LEN: (.*)#\1#p' <<< "$tmp"`
	local off=`sed -rn 's#OFF: (.*)#\1#p' <<< "$tmp"`
	[[ -n "$len" && -n "$off" ]] || return 1
	#dd if=$FIT skip=$off count=$len iflag=skip_bytes,count_bytes 2>/dev/null
	tail -c +$((off + 1)) $FIT 2>/dev/null | head -c $len 2>/dev/null
}

fit_prop_string() {
	fit_prop "$@" | tr -d '\0'
}

fit_blob_size() {
	local tmp=`fit_info -f $FIT -n /images/$1 -p data`
	sed -rn 's#LEN: (.*)#\1#p' <<< "$tmp"
}

fit_blob_data() {
	fit_prop "/images/$1" data
}

fit_blob_hash() {
	fit_prop "/images/$1/hash@1" value | to_hex
}

fit_blob_verify_hash() {
	local name=$1
	local sha1_expected=`fit_blob_hash $name`

	info "Checking SHA1 hash of $name"
	
	local blob_size=`fit_blob_size rootfs`
	local tmp=`mktemp -p $TMPDIR`
	(
		echo 0
		fit_blob_data $name | pv -n -s "$blob_size" | sha1sum | cut -f1 -d' ' > $tmp
	) 2>&1 | mqtt_progress "$x"
	local sha1_calculated=`cat $tmp`
	rm $tmp

	[[ "$sha1_expected" == "$sha1_calculated" ]] &&
		info "SHA1 hash of $name ok" ||
		die "SHA1 of $name doesn't match (expected $sha1_expected, got $sha1_calculated)"
}

led_process

>&2 cat <<EOF
===============================================================================
`date`: started update from $FIT
===============================================================================
Description:         $(fit_prop_string / description)
Compatible device:   $(fit_prop_string / compatible)
Firmware version:    $(fit_prop_string / firmware-version)
Firmware compatible: $(fit_prop_string / firmware-compatible)
Time of creation:    $(date -d @$[0x$(fit_prop / timestamp | to_hex)])
===============================================================================

EOF

fit_blob_verify_hash install

info "Extracting install script"
INSTALL_SCRIPT=`mktemp -p $TMPDIR`
fit_blob_data install > "$INSTALL_SCRIPT" || die

info "Running install script"
source "$INSTALL_SCRIPT"

rm -f "$INSTALL_SCRIPT"
